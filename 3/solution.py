import math


def fastExpMod(b, e, m):
    result = 1
    while e != 0:
        if (e & 1) == 1:
            result = (result * b) % m
        e >>= 1
        b = (b * b) % m
    return result


def brute_force_dl(mod, gen, order, target):
    """
    Uses a naive brute-force approach to compute x such that gen^x = target (mod mod),
    where x is in [0, order-1].
    """
    val = 1
    for x in range(order):
        if val == target:
            return x
        val = (val * gen) % mod
    return None  # Should not happen if target is really in the subgroup.


def baby_step_giant_step_dl(mod, gen, order, target):
    """
    Uses the baby-step giant-step algorithm to compute x such that gen^x = target (mod mod),
    with x in [0, order-1].
    """
    m = int(math.ceil(order ** 0.5))

    # Baby-step: store gen^j for j in [0..m-1] in a dictionary mapping value -> exponent j.
    baby_table = {}
    cur = 1
    for j in range(m):
        # If not present, store the exponent j for this value
        baby_table[cur] = j
        cur = (cur * gen) % mod

    # gen^(-m) = gen^(order - m) mod mod (since gen^order = 1 in this subgroup).
    # We will repeatedly multiply 'target' by this factor and check if it appears in baby_table.
    factor = pow(gen, order - m, mod)
    cur = target
    for i in range(m):
        # Check if the current value is in the baby-step table.
        if cur in baby_table:
            # We have gen^(m*i + baby_table[cur]) = target
            return i * m + baby_table[cur]
        # Multiply by gen^(-m)
        cur = (cur * factor) % mod

    return None  # Should not happen if there's a valid solution in the subgroup.


def crt(vals, mods):
    """Optimized Chinese Remainder Theorem using Garner's Algorithm."""
    x = vals[0]
    m = mods[0]

    for i in range(1, len(mods)):
        mi = mods[i]
        ai = vals[i]

        # Compute modular inverse
        mi_inv = pow(m, -1, mi)
        diff = (ai - x) % mi
        x = x + (diff * mi_inv % mi) * m
        m *= mi

    return x % m


def pohlig_hellman_prime_power(p, e, g, h, mod):
    """
    Solves the discrete logarithm problem g^x = h (mod mod) for a cyclic group of order p^e.

    Parameters:
        p (int): Prime base of the group order.
        e (int): Exponent defining the order as p^e.
        g (int): Generator of the group.
        h (int): Target element.
        mod (int): The modulus (prime defining Z*_mod).

    Returns:
        x (int): The unique integer x in {0, ..., p^e - 1} such that g^x = h.
    """
    # Step 1: Initialize x_0 = 0
    x = 0

    # Step 2: Compute γ = g^(p^(e-1))
    gamma = pow(g, p ** (e - 1), mod)

    # Step 3: Iteratively compute x_k using the baby-step giant-step algorithm
    for k in range(e):
        # Compute h_k = (g^(-x_k) * h)^(p^(e-1-k))
        g_inv_x = pow(g, -x, mod)  # g^(-x) mod p
        h_k = pow((g_inv_x * h) % mod, p ** (e - 1 - k), mod)

        # Compute d_k such that γ^(d_k) = h_k using baby-step giant-step
        d_k = baby_step_giant_step_dl(mod, gamma, p, h_k)

        # Update x: x_{k+1} = x_k + p^k * d_k
        x = x + d_k * (p ** k)

    # Step 4: Return the computed x
    return x


def pohlig_hellman(mod, gen, factors, target):
    """Uses the Pohlig-Hellman algorithm to compute discrete log of target with
    respect to gen, given the factorization of the order of the subgroup
    generated by gen.

    Parameters:
        mod (int): The prime modulus over which computation is carried out.
        gen (int): An element of Z*_mod.
        factors (list(int, int)): A list of values [(p_1, e_1), ..., (p_n, e_n)] such that the order
            of the subgroup generated by gen is p_1^{e_1} * ... * p_n^{e_n}.
        target (int): The element whose discrete log is to be computed.

    Returns:
        int: The discrete log of target with respect to gen.
    """
    # 1)
    Q = mod - 1
    # 2)
    mods_for_crt = []
    vals_for_crt = []
    for (prime, exponent) in factors:
        # 2.1
        power_factor = prime ** exponent
        g_i = pow(gen, Q // power_factor, mod)  # g^(Q/(p^e)) mod
        h_i = pow(target, Q // power_factor, mod)  # h^(Q/(p^e)) mod
        x_i = pohlig_hellman_prime_power(prime, exponent, g_i, h_i, mod)
        mods_for_crt.append(power_factor)
        vals_for_crt.append(x_i)

    # 3)
    return crt(vals_for_crt, mods_for_crt)


def elgamal_attack(params, pk):
    """
    Recovers the secret key sk for an ElGamal public key pk = params.gen^sk (mod params.mod).
    We assume that sk < params.exp_bound, and that there is a large enough 'smooth' subgroup
    in Z*_{params.mod} (of order ≥ params.exp_bound) allowing us to recover sk uniquely.

    Strategy:
      1. Pick a subset of the prime-power factors of (mod-1) whose product >= exp_bound.
      2. Restrict computation to that subgroup of size >= exp_bound.
      3. Use Pohlig–Hellman in that subgroup.
    """
    p = params.mod
    g = params.gen
    B = params.exp_bound  # upper bound on secret key
    full_factors = params.factors  # [(p_1, e_1), (p_2, e_2), ...]

    # 1) Collect enough prime-power factors so that their product ≥ B
    #    The order of g is (p - 1) or divides (p - 1). We'll build a "subgroup factor" that is >= B.
    sub_factors = []
    sub_order = 1
    # Sort from smallest prime to largest, or vice versa; either is fine, as long as we reach >= B.
    for (prime, e) in sorted(full_factors, key=lambda x: x[0]):
        sub_factors.append((prime, e))
        sub_order *= prime ** e
        if sub_order >= B:
            break

    # 2) Form the generator of the chosen subgroup: g_sub = g^((p-1) / sub_order) mod p
    #    and the corresponding pk_sub = pk^((p-1) / sub_order) mod p
    exponent = (p - 1) // sub_order
    g_sub = pow(g, exponent, p)
    pk_sub = pow(pk, exponent, p)

    # 3) Compute x in [0..sub_order-1] s.t. g_sub^x = pk_sub (mod p).
    x = pohlig_hellman(p, g_sub, sub_factors, pk_sub)

    # x must be unique if x < sub_order and sub_order ≥ B (and we know sk < B).
    return x
